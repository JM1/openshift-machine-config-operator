mode: 0755
path: "/usr/local/bin/prepare-ovs.sh"
contents:
  inline: |
    #!/bin/bash
    set -x

    # Used to print network state
    print_state() {
      echo "Current device, connection, interface and routing state:"
      ip -d address show
      ip route show
      ip -6 route show
      ovs-vsctl show
    }

    # Setup an exit trap to rollback on error
    handle_exit() {
      e=$?
      print_state
      exit $e
    }

    # Setup a signal trap to rollback
    handle_termination() {
      echo "WARNING: prepare-ovs has been requested to terminate, quitting..."

      # by exiting with an error we will cleanup after ourselves in a
      # subsequent call to handle_exit
      exit 1
    }

    # main function
    prepare_ovs() {
      set -eu

      # setup traps to handle signals and other abnormal exits
      trap 'handle_termination' TERM INT
      trap 'handle_exit' EXIT

      if ! rpm -qa | grep -q openvswitch; then
        echo "WARNING: Openvswitch package is not installed!"
        exit 1
      fi

      # print initial state
      print_state

      if [ "$1" = "OVNKubernetes" ]; then
        if grep -w -q ovs-dpdk-vduse-poc /proc/cmdline; then
          # Load VFIO modules early otherwise ovs-vswitchd will not be able to use NICs with DPDK drivers.
          #
          # The following kernel arguments might be useful:
          #
          # * vfio.enable_unsafe_noiommu_mode=1
          #   When attaching NICs with DPDK drivers to Open vSwitch when no IOMMU is available.
          #
          # * vfio_iommu_type1.allow_unsafe_interrupts=1
          #   When attaching NICs with DPDK drivers to Open vSwitch when interrupt remapping is not
          #   enabled (QEMU's Intel IOMMU) or not supported (QEMU's virtio IOMMU)
          #
          # TODO: Replace with files in /etc/modules-load.d/ and /etc/modprobe.d/
          modprobe vfio-pci

          # Enable VDUSE support
          # TODO: Replace with files in /etc/modules-load.d/
          modprobe vduse
          modprobe virtio-vdpa
          modprobe vhost-vdpa

          # Enable DPDK
          ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=true
          ovs-vsctl --no-wait set Open_vSwitch . other_config:userspace-tso-enable=true
          ovs-vsctl --no-wait set open . external-ids:ovn-bridge-datapath-type="netdev"

          # Render DPDK's initial probing futile in order to prevent init order issues
          ovs-vsctl --no-wait set open . other_config:dpdk-extra='-a 0000:00:00.0'

          # Save power with OVS-DPDK PMD thread load-based sleeping
          # Ref.: https://developers.redhat.com/articles/2023/10/16/save-power-ovs-dpdk-pmd-thread-load-based-sleeping
          ovs-vsctl --no-wait set Open_vSwitch . other_config:pmd-sleep-max=0
          (
            set -- $(cat /proc/cmdline)
            for arg in "$@"; do
              case "$arg" in
                ovs-pmd-sleep-max=*)
                  ovs-vsctl --no-wait set Open_vSwitch . "other_config:pmd-sleep-max=${arg#ovs-pmd-sleep-max=}"
                  ;;
              esac
            done
          )

          # Run OVS as root user to allow OVS to manage VDUSE devices
          # TODO: Replace with proper solution to allow OVS to manage VDUSE devices.
          ovs_user=$(. /etc/sysconfig/openvswitch && echo "${OVS_USER_ID:-root:root}" | cut -d ":" -f 1)
          if [ "$ovs_user" != "root" ]; then
            cp -av "/etc/sysconfig/openvswitch" "/etc/sysconfig/openvswitch.bak.ovs-dpdk-vduse-poc"
            sed -i -e 's/^OVS_USER_ID=/# OVS_USER_ID=/g' /etc/sysconfig/openvswitch
            echo 'OVS_USER_ID="root:root"' >> /etc/sysconfig/openvswitch

            # Reboot to apply changes because systemd will not (re)load environment variable OVS_USER_ID when
            # running "systemctl daemon-reload" and "systemctl restart --no-block ovs-vswitchd.service".
            systemctl reboot
            exit 255
          fi

          if grep -w -q ovs-dpdk-dbg /proc/cmdline; then
            ovs-vsctl --no-wait set open . \
              other_config:dpdk-extra='-a 0000:00:00.0 --log-level=pmd.net.virtio.*:debug --log-level=lib.eal:debug'

            ovs_options=$(. /etc/sysconfig/openvswitch && echo "${OPTIONS:-}" | cut -d ":" -f 1)
            if [ -n "$ovs_options" ]; then
              echo "WARNING: OPTIONS has already been defined in /etc/sysconfig/openvswitch"
            else
              if [ ! -e "/etc/sysconfig/openvswitch.bak.ovs-dpdk-vduse-poc" ]; then
                cp -av "/etc/sysconfig/openvswitch" "/etc/sysconfig/openvswitch.bak.ovs-dpdk-vduse-poc"
              fi

              sed -i -e 's/^OPTIONS=/# OPTIONS=/g' /etc/sysconfig/openvswitch
              echo 'OPTIONS="--ovs-vswitchd-options='\''-vfile:dpdk:dbg'\''"' >> /etc/sysconfig/openvswitch

              # Reboot to apply changes because systemd will not (re)load environment variable OPTIONS when
              # running "systemctl daemon-reload" and # "systemctl restart --no-block ovs-vswitchd.service".
              systemctl reboot
              exit 255
            fi
          fi
        else
          # Disable DPDK
          ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=false
          ovs-vsctl --no-wait set Open_vSwitch . other_config:userspace-tso-enable=false
          ovs-vsctl --no-wait --if-exists remove open . external-ids ovn-bridge-datapath-type="netdev"
          ovs-vsctl --no-wait --if-exists remove open . other_config dpdk-extra

          # Restore previous OVS configuration, e.g. revoke privilege for
          # managing VDUSE devices from OVS and disable debug output
          # TODO: Replace with proper solution to allow OVS to manage VDUSE devices.
          if [ -e "/etc/sysconfig/openvswitch.bak.ovs-dpdk-vduse-poc" ]; then
            mv -v "/etc/sysconfig/openvswitch.bak.ovs-dpdk-vduse-poc" "/etc/sysconfig/openvswitch"

            # Reboot to apply changes because systemd will not (re)load environment variable OVS_USER_ID when
            # running "systemctl daemon-reload" and "systemctl restart --no-block ovs-vswitchd.service".
            systemctl reboot
            exit 255
          fi
        fi
      fi
    }

    # Retry prepare_ovs until it succeeds.
    # By default, retry every 15 minutes to give enough time to gather
    # troubleshooting information in between. Note that prepare_ovs has other
    # internal retry mechanisms. This retry is intended to give some
    # self-healing capabilities to temporary but not necessarily short-lived
    # infrastructure problems.
    RETRY="${RETRY-15m}"
    while true; do

      # Disable retries if termination signal is received. Note that systemd
      # sends the signals to all processes in the group by default so we expect
      # prepare_ovs to get its own signals.
      trap 'echo "WARNING: termination requested, disabling retries"; RETRY=""' INT TERM

      # Run prepare_ovs in a sub-shell.
      ( prepare_ovs "$@" )
      e=$?

      # Handle signals while we sleep
      trap 'handle_termination' INT TERM

      # Exit if succesful and not configured to retry
      [ "$e" -eq 0 ] || [ -z "$RETRY" ] && exit "$e"

      echo "prepare-ovs failed, will retry after $RETRY"
      # flag that a retry has happened
      touch /tmp/prepare-ovs-retry
      sleep "$RETRY"

    done
